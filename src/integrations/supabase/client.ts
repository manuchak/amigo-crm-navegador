
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://beefjsdgrdeiymzxwxru.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJlZWZqc2RncmRlaXltenh3eHJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI5MzI1OTQsImV4cCI6MjA1ODUwODU5NH0.knvlRdFYtN2bl3t3I4O8v3dU_MWKDDuaBZkvukdU87w";
// Service role key is only used securely server-side
const SUPABASE_SERVICE_ROLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJlZWZqc2RncmRlaXltenh3eHJ1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0MjkzMjU5NCwiZXhwIjoyMDU4NTA4NTk0fQ.7alp-dJOJPuUEjiWb71LOFlRFE6QrQQxuXXSTBJwyAM";

// Create standard client for authenticated users with proper configuration
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storage: typeof window !== 'undefined' ? window.localStorage : undefined
    }
  }
);

/**
 * More reliable implementation of owner role checking that uses both
 * localStorage and current session if available
 */
export const checkForOwnerRole = async (): Promise<boolean> => {
  try {
    // First check localStorage as a fast path
    if (typeof window !== 'undefined') {
      const currentUserStr = localStorage.getItem('current_user');
      if (currentUserStr) {
        try {
          const userData = JSON.parse(currentUserStr);
          if (userData && userData.role === 'owner') {
            console.log('Owner detected via localStorage');
            return true;
          }
        } catch (e) {
          console.error("Error parsing localStorage user data:", e);
        }
      }
    }
    
    // Then verify with active session if available
    try {
      const { data } = await supabase.auth.getSession();
      if (data?.session) {
        // Try to get user role from RPC function
        const { data: roleData, error: roleError } = await supabase
          .rpc('get_user_role', { user_uid: data.session.user.id })
          .single();
          
        if (!roleError && roleData === 'owner') {
          console.log('Owner detected via session');
          return true;
        }
      }
    } catch (sessionError) {
      console.error("Error checking session for owner role:", sessionError);
    }
    
    return false;
  } catch (e) {
    console.error("Error in checkForOwnerRole:", e);
    return false;
  }
};

/**
 * Creates and returns a fresh Supabase admin client with service role key
 */
export const getAdminClient = () => {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    console.error("Error crítico: Faltan credenciales de Supabase");
    throw new Error("Error de configuración: faltan credenciales de Supabase");
  }

  try {
    // Create a new client with the service role key
    return createClient<Database>(
      SUPABASE_URL,
      SUPABASE_SERVICE_ROLE_KEY,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    );
  } catch (error) {
    console.error("Error al crear cliente admin:", error);
    throw new Error("Error crítico al inicializar cliente de administración");
  }
};

// For compatibility with existing code
export const supabaseAdmin = getAdminClient();

/**
 * Enhanced function to ensure we always have a valid client for API operations
 * with proper security handling
 */
export const getAuthenticatedClient = async () => {
  // First check if user is owner (faster path) using the async version
  const isOwner = await checkForOwnerRole();
  
  if (isOwner) {
    console.log("✅ Owner role detected - using fresh admin client");
    return getAdminClient();
  }

  try {
    // Check current session
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError) {
      console.error("Session error:", sessionError);
      throw new Error(`Error al verificar la sesión: ${sessionError.message}`);
    }
    
    if (!session) {
      console.warn("No active session found");
      
      // Final check for owner role as fallback before failing
      if (await checkForOwnerRole()) {
        console.log("No session but owner role detected in fallback - using admin client");
        return getAdminClient();
      }
      
      throw new Error("No hay sesión activa. Por favor inicie sesión nuevamente.");
    }
    
    // Ensure token is valid by checking expiration
    const tokenExpiration = session.expires_at ? new Date(session.expires_at * 1000) : null;
    const isTokenExpired = tokenExpiration && tokenExpiration < new Date();
    
    if (isTokenExpired) {
      console.warn("Token expired, attempting refresh");
      const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();
      
      if (refreshError || !refreshData.session) {
        console.error("Token refresh failed:", refreshError);
        throw new Error("Su sesión ha expirado. Por favor inicie sesión nuevamente.");
      }
    }
    
    console.log("Using authenticated client with valid session");
    return supabase;
  } catch (error) {
    console.error("Auth client error:", error);
    
    // Always fallback to admin client for owners even if there are errors
    if (await checkForOwnerRole()) {
      console.log("Error occurred but owner detected - using fresh admin client");
      return getAdminClient();
    }
    
    throw error;
  }
};

/**
 * Secure method to validate user permissions using RLS policies
 * This should be used instead of direct role checks where possible
 */
export const checkUserPermission = async (permissionType: 'page' | 'action', permissionId: string): Promise<boolean> => {
  try {
    const client = await getAuthenticatedClient();
    
    // Use RLS policies to enforce permissions
    const { data, error } = await client
      .from('role_permissions')
      .select('allowed')
      .match({ 
        permission_type: permissionType,
        permission_id: permissionId
      })
      .single();
    
    if (error) {
      console.error(`Permission check error for ${permissionType}:${permissionId}:`, error);
      return false;
    }
    
    return data?.allowed || false;
  } catch (error) {
    console.error("Error checking permission:", error);
    return false;
  }
};
